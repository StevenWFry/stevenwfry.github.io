<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lesson 20 – Manipulating Data Using Advanced Queries (or: how to break reality faster and more efficiently) - SQL Guide - swf.wtf</title>
<meta name="description" content="And look, basic `INSERT`, `UPDATE`, and `DELETE` are cute. They’re the training wheels of SQL. But at some point you stop gently adding rows and start doi...">
<link rel="stylesheet" href="../assets/css/site.css">
<link rel="stylesheet" href="../assets/css/sql-guide.css">
</head>
<body>

<div class="cursor" id="cursor"></div>

<nav>
  <div class="inner">
    <a href="../index.html" class="logo">swf.wtf</a>
    <a href="index.html">&larr; sql guide</a>
  </div>
</nav>

<main class="sql-page">
  <header class="sql-header">
    <div class="sql-eyebrow">SQL Guide Chapter</div>
    <h1>Lesson 20 – Manipulating Data Using Advanced Queries (or: how to break reality faster and more efficiently)</h1>
    <p>And look, basic `INSERT`, `UPDATE`, and `DELETE` are cute. They’re the training wheels of SQL. But at some point you stop gently adding rows and start doing things like loading three tables at once, rewriting history, a...</p>
    <div class="sql-meta">
      <span class="sql-pill">oracle 19c</span>
      <span class="sql-pill">mysql notes</span>
      <span class="sql-pill">study chapter</span>
    </div>
  </header>

  <article class="chapter">
    <p>And look, basic <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> are cute. They’re the training wheels of SQL. But at some point you stop gently adding rows and start doing things like loading three tables at once, rewriting history, and bringing dropped tables back from the dead like a mildly confused necromancer.</p>
    <p>In this lesson you will:</p>
    <ul>
    <li>Use explicit <code>DEFAULT</code> values in <code>INSERT</code> and <code>UPDATE</code> statements.</li>
    <li>Describe the features of <strong>multi-table inserts</strong>.</li>
    <li>Use these types of multi-table inserts:</li>
    <li>unconditional <code>INSERT ALL</code></li>
    <li>conditional <code>INSERT ALL</code></li>
    <li>conditional <code>INSERT FIRST</code></li>
    <li>pivoting inserts</li>
    <li>Merge rows in a table with <code>MERGE</code>.</li>
    <li>Perform <strong>flashback</strong> operations.</li>
    <li>Track changes made to data over a period of time.</li>
    </ul>
    <hr>
    <h2>1. Explicit DEFAULT Values in INSERT and UPDATE</h2>
    <p>And look, defaults in tables are like emergency snacks in your desk drawer: they’re great, but only if you actually use them on purpose.</p>
    <p>Normally, a column’s default value only appears when you <strong>omit</strong> that column. With the <code>DEFAULT</code> keyword you can say, “no, seriously, use the default here.”</p>
    <ul>
    <li>You can use <code>DEFAULT</code> anywhere a normal value would go.</li>
    <li>If the column has a default defined, Oracle uses it.</li>
    <li>If it doesn’t, Oracle cheerfully gives you <code>NULL</code>.</li>
    </ul>
    <p><strong>Example INSERT:</strong></p>
    <pre><code class="language-sql">INSERT INTO deptm3 (department_id, department_name, manager_id)
    VALUES (300, &#x27;Engineering&#x27;, DEFAULT);</code></pre>
    <ul>
    <li><code>department_id</code> = 300</li>
    <li><code>department_name</code> = &#x27;Engineering&#x27;</li>
    <li><code>manager_id</code> = its default, or <code>NULL</code> if there isn’t one</li>
    </ul>
    <p><strong>Example UPDATE:</strong></p>
    <pre><code class="language-sql">UPDATE deptm3
    SET    manager_id = DEFAULT
    WHERE  department_id = 10;</code></pre>
    <p>If <code>manager_id</code> has no default in the table definition, this effectively sets it to <code>NULL</code>. So <code>DEFAULT</code> is either a well-defined rule or a very fancy way of writing “I dunno, make it empty.”</p>
    <hr>
    <h2>2. Multi-Table Inserts: One SELECT, Many Targets</h2>
    <p>Multi-table inserts are Oracle’s way of saying, “What if a single query could explode into several tables at once?” It’s very efficient and very dangerous if you weren’t paying attention.</p>
    <p>They are heavily used in <strong>data warehousing</strong> to:</p>
    <ul>
    <li>Pull data from one or more source tables.</li>
    <li>Push it into several target tables in <strong>one</strong> DML statement.</li>
    <li>Avoid writing 14 separate <code>INSERT</code> statements or a procedural <code>IF/THEN</code> jungle.</li>
    </ul>
    <p>You’ll see four flavors:</p>
    <ol>
    <li>Unconditional <code>INSERT ALL</code></li>
    <li>Conditional <code>INSERT ALL</code></li>
    <li>Conditional <code>INSERT FIRST</code></li>
    <li>Pivoting inserts</li>
    </ol>
    <h3>2.1 Unconditional INSERT ALL (copy everything everywhere)</h3>
    <p>In the e‑commerce example, we have three customers—Tom, Dick, and Harry—each with their own order table. A single purchase row should be copied into <strong>all three</strong> tables.</p>
    <p>This is an unconditional multi-table insert, also called <code>INSERT ALL</code>:</p>
    <pre><code class="language-sql">INSERT ALL
      INTO sal_history     (employee_id, hire_date, salary, manager_id)
      INTO mgr_history     (employee_id, hire_date, salary, manager_id)
    SELECT employee_id, hire_date, salary, manager_id
    FROM   employees
    WHERE  employee_id &gt; 200;</code></pre>
    <ul>
    <li>If the <code>SELECT</code> returns 6 rows and there are 2 targets, you get <strong>12</strong> inserts.</li>
    <li>With 3 targets and 100 rows, you’d get <strong>300</strong> rows inserted.</li>
    </ul>
    <p>Every target table gets <strong>every</strong> row. No conditions. No nuance. Pure duplication.</p>
    <hr>
    <h3>2.2 Conditional INSERT ALL (rows can hit multiple tables)</h3>
    <p>Now we add conditions. Each <code>INTO</code> clause can have a <code>WHEN</code> condition, which means a row may go into:</p>
    <ul>
    <li>zero tables,</li>
    <li>one table, or</li>
    <li>several tables.</li>
    </ul>
    <p><strong>Pattern:</strong></p>
    <pre><code class="language-sql">INSERT ALL
      WHEN hire_date &lt; DATE &#x27;2015-01-01&#x27; THEN
        INTO emp_history (emp_id, hire_date, salary)
        VALUES (empno, hdate, sal)
      WHEN commission_pct IS NOT NULL THEN
        INTO emp_sales (emp_id, salary, commission_pct)
        VALUES (empno, sal, comm)
    SELECT employee_id    AS empno,
           hire_date      AS hdate,
           salary         AS sal,
           commission_pct AS comm
    FROM   employees;</code></pre>
    <p>Key detail: <strong>all matching conditions fire</strong>.</p>
    <ul>
    <li>If an employee was hired before 2015 <strong>and</strong> has a commission, that row goes into <strong>both</strong> <code>emp_history</code> and <code>emp_sales</code>.</li>
    <li>In the demo, 25 source rows turned into 49 inserted rows, because some were inserted into multiple tables.</li>
    </ul>
    <p>So <code>INSERT ALL</code> really means: “insert into <strong>all</strong> the tables whose conditions you match, possibly more than once.”</p>
    <hr>
    <h3>2.3 Conditional INSERT FIRST (each row finds exactly one home)</h3>
    <p>Now we change the rules: each row should pick <strong>one</strong> target, based on the first condition it satisfies.</p>
    <p>That’s <code>INSERT FIRST</code>.</p>
    <p><strong>Example:</strong> bucket salaries into low, mid, and high tables:</p>
    <pre><code class="language-sql">INSERT FIRST
      WHEN salary &lt; 5000 THEN
        INTO sal_low (employee_id, salary) VALUES (empno, sal)
      WHEN salary BETWEEN 5000 AND 10000 THEN
        INTO sal_mid (employee_id, salary) VALUES (empno, sal)
      ELSE
        INTO sal_high (employee_id, salary) VALUES (empno, sal)
    SELECT employee_id AS empno,
           salary      AS sal
    FROM   employees;</code></pre>
    <ul>
    <li>Oracle checks the <code>WHEN</code> clauses <strong>in order</strong>.</li>
    <li>The first one that matches wins; the row goes only into that target.</li>
    <li>The demo’s <code>SELECT</code> returned 107 rows, and—this time—107 rows were inserted total.</li>
    </ul>
    <p>This is basically salary sorting-hat logic: every row gets exactly one house.</p>
    <hr>
    <h3>2.4 Pivoting Inserts (columns → rows)</h3>
    <p>Now we get weird in a fun way: we take one row that has <strong>many columns</strong>, and turn it into <strong>many rows</strong> in the target.</p>
    <p>Imagine a source table with weekly sales summarized per day:</p>
    <pre><code class="language-text">WEEK_ID  MON  TUE  WED  THU  FRI
    -------  ---  ---  ---  ---  ---
        1    10   15   12   20   18</code></pre>
    <p>We want a target with <strong>one row per day</strong>:</p>
    <pre><code class="language-text">WEEK_ID  DAY_NAME  QTY_SOLD
    -------  --------  --------
    1        MON       10
    1        TUE       15
    ...</code></pre>
    <p><strong>Pivoting insert:</strong></p>
    <pre><code class="language-sql">INSERT ALL
      INTO emp_sales_info (week_id, day_name, qty_sold)
        VALUES (week_id, &#x27;MON&#x27;, mon)
      INTO emp_sales_info (week_id, day_name, qty_sold)
        VALUES (week_id, &#x27;TUE&#x27;, tue)
      INTO emp_sales_info (week_id, day_name, qty_sold)
        VALUES (week_id, &#x27;WED&#x27;, wed)
      INTO emp_sales_info (week_id, day_name, qty_sold)
        VALUES (week_id, &#x27;THU&#x27;, thu)
      INTO emp_sales_info (week_id, day_name, qty_sold)
        VALUES (week_id, &#x27;FRI&#x27;, fri)
    SELECT week_id,
           mon, tue, wed, thu, fri
    FROM   sales_week_data;</code></pre>
    <ul>
    <li>One input row becomes <strong>five</strong> output rows.</li>
    <li>Now aggregations like “total sales per week” become easy:</li>
    </ul>
    <pre><code class="language-sql">SELECT week_id,
           SUM(qty_sold) AS week_total
    FROM   emp_sales_info
    GROUP  BY week_id;</code></pre>
    <p>This is Oracle politely fixing a non-normalized design while pretending nothing is wrong.</p>
    <hr>
    <h2>3. MERGE: Conditional Update / Insert / Delete (Upsert on steroids)</h2>
    <p>The <code>MERGE</code> statement is what you use when you’re tired of writing “check if it exists, then update, otherwise insert” logic in three different places.</p>
    <ul>
    <li>If a row <strong>matches</strong> (based on a join condition), you can <code>UPDATE</code> it (and optionally <code>DELETE</code> it).</li>
    <li>If it <strong>doesn’t match</strong>, you can <code>INSERT</code> it.</li>
    </ul>
    <p><strong>Pattern:</strong></p>
    <pre><code class="language-sql">MERGE INTO emp_hist h
    USING employees e
    ON (h.employee_id = e.employee_id)
    WHEN MATCHED THEN
      UPDATE SET
        h.first_name = e.first_name,
        h.last_name  = e.last_name,
        h.email      = e.email
    WHEN NOT MATCHED THEN
      INSERT (employee_id, first_name, last_name, email)
      VALUES (e.employee_id, e.first_name, e.last_name, e.email);</code></pre>
    <p>In the demo:</p>
    <ul>
    <li><code>EMP_HIST</code> already had 107 employees but with some missing/old data.</li>
    <li>They manually broke some rows (e.g., mangled Jennifer Whalen’s email, removed Eleni Zlotkey).</li>
    <li>Running <code>MERGE</code>:</li>
    <li><strong>Updated</strong> existing rows to match <code>employees</code>.</li>
    <li><strong>Inserted</strong> missing rows like Eleni.</li>
    <li>Reported “107 rows merged,” syncing history with the current truth.</li>
    </ul>
    <p>You can also add a <code>DELETE</code> clause inside <code>WHEN MATCHED</code> to remove rows matching some condition (e.g., anyone with a commission), turning <code>MERGE</code> into the DML equivalent of “fix this table or get rid of it.”</p>
    <hr>
    <h2>4. Flashback Table: Undo for Grown-Ups</h2>
    <p>And look, everyone eventually drops the wrong table. Oracle’s flashback features exist because that moment should be embarrassing, not career-ending.</p>
    <p><code>FLASHBACK TABLE</code> lets you:</p>
    <ul>
    <li>Recover a <strong>dropped</strong> table from the Recycle Bin.</li>
    <li>Restore a table to a previous <strong>point in time</strong> or <strong>SCN</strong>.</li>
    <li>Bring back data, indexes, and constraints in one go.</li>
    </ul>
    <p><strong>Example: recovering a dropped table</strong></p>
    <pre><code class="language-sql">-- Table is created
    CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1 = 0;
    
    -- Table is dropped (it goes to the Recycle Bin)
    DROP TABLE emp2;
    
    -- Recover it
    FLASHBACK TABLE emp2 TO BEFORE DROP;</code></pre>
    <p>After flashback:</p>
    <ul>
    <li>The table structure (and data, if it had any) is back.</li>
    <li>The Recycle Bin entry disappears.</li>
    </ul>
    <p>This is essentially “Control+Z for tables,” as long as you didn’t purge the bin.</p>
    <hr>
    <h2>5. Tracking Data Changes Over Time</h2>
    <p>Sometimes you don’t want to <em>revert</em> the table; you just want to <strong>peek into the past</strong> and see how bad your decisions were.</p>
    <p>Oracle can show you previous committed versions of a row using undo data, as long as that undo hasn’t been overwritten.</p>
    <h3>5.1 Row version history with VERSIONS BETWEEN</h3>
    <p>In the demo, they kept changing Steven King’s salary:</p>
    <ul>
    <li>24000 → 1 → 10 → back to 24000.</li>
    </ul>
    <p>Then they queried the history:</p>
    <pre><code class="language-sql">SELECT
      VERSIONS_STARTTIME AS start_time,
      VERSIONS_ENDTIME   AS end_time,
      salary
    FROM   employees
    VERSIONS BETWEEN SCN MINVALUE AND MAXVALUE
    WHERE  employee_id = 100;</code></pre>
    <p>This shows:</p>
    <ul>
    <li>Each salary value.</li>
    <li>When it became valid.</li>
    <li>When it stopped being valid (current version has no end time).</li>
    </ul>
    <p>It’s like a security camera for row values.</p>
    <h3>5.2 Time-based flashback with AS OF</h3>
    <p>You can also query “what did this row look like N minutes ago?” using <code>AS OF</code> and <code>INTERVAL</code>:</p>
    <pre><code class="language-sql">SELECT salary
    FROM   employees3
    AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL &#x27;1&#x27; MINUTE)
    WHERE  last_name = &#x27;Chung&#x27;;</code></pre>
    <p>As long as the undo for that time window still exists, you can:</p>
    <ul>
    <li>See the previous salary.</li>
    <li>Compare old vs. new values.</li>
    <li>Prove, with receipts, that someone really did set a salary to 1.</li>
    </ul>
    <hr>
    <h2>6. What You Should Now Be Able to Do</h2>
    <p>By the end of this lesson, you should be able to:</p>
    <ul>
    <li>Specify explicit default values in <code>INSERT</code> and <code>UPDATE</code> statements using <code>DEFAULT</code>.</li>
    <li>Describe how multi-table inserts work and when to use them.</li>
    <li>Use:</li>
    <li>unconditional <code>INSERT ALL</code>,</li>
    <li>conditional <code>INSERT ALL</code>,</li>
    <li>conditional <code>INSERT FIRST</code>, and</li>
    <li>pivoting inserts.</li>
    <li>Use <code>MERGE</code> to conditionally update, insert, and optionally delete rows.</li>
    <li>Perform flashback operations to recover tables or restore them to earlier states.</li>
    <li>Track changes made to data over time using row version queries and time-based flashback.</li>
    </ul>
    <p>And if all of this feels like a ridiculous amount of power, that’s because it is. You can now duplicate data across multiple tables, rewrite history, and resurrect dropped objects—so please, use these features more responsibly than the demo script that set Steven King’s salary to $1 on purpose.</p>
  </article>

  <div class="chapter-nav">
    <a href="18_Controlling_User_Access.html">&larr; previous</a>
    <a href="19_Manipulating_Data_Using_Advanced_Queries.md">view source markdown</a>
    <a href="20_Managing_Data_in_Different_Time_Zones.html">next &rarr;</a>
  </div>

  <div class="sql-footer">// sql-guide generated from markdown notes</div>
</main>

<script defer src="../assets/js/site.js"></script>

</body>
</html>
